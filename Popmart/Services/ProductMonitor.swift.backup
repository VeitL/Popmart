//
//  ProductMonitor.swift
//  Popmart
//
//  Created by Guanchenuous on 29.05.25.
//

import Foundation
import Combine
import SwiftUI
import WebKit
import OSLog

class ProductMonitor: ObservableObject {
    @Published var products: [Product] = []
    @Published var monitorLogs: [MonitorLog] = []
    @Published var lastError: String?
    
    private var productTimers: [UUID: Timer] = [:]
    private var variantTimers: [String: Timer] = [:]  // æ–°å¢ï¼šå˜ä½“å®šæ—¶å™¨ï¼Œkeyæ ¼å¼ä¸º "productId_variantId"
    private var cancellables = Set<AnyCancellable>()
    
    // åçˆ¬è™«ç”¨æˆ·ä»£ç†æ± 
    private let userAgents = [
        "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.6 Mobile/15E148 Safari/604.1",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    ]
    
    // è¯·æ±‚å¤´æ± 
    private let acceptLanguages = [
        "zh-CN,zh;q=0.9,en;q=0.8",
        "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7",
        "de-DE,de;q=0.9,en;q=0.8",
        "ja-JP,ja;q=0.9,en;q=0.8"
    ]
    
    // è®¡ç®—å±æ€§ï¼šæ˜¯å¦æœ‰ä»»ä½•äº§å“åœ¨ç›‘æ§ä¸­
    var isAnyMonitoring: Bool {
        products.contains { $0.isMonitoring }
    }
    
    // æ·»åŠ æ—¥å¿—è®°å½•å™¨
    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "com.popmart", category: "ProductMonitor")
    
    init() {
        loadProducts()
        loadLogs()
        // æ·»åŠ é»˜è®¤å•†å“
        if products.isEmpty {
            addProduct(url: "https://www.popmart.com/de/products/1991/THE-MONSTERS-Big-into-Energy-Series-Vinyl-Plush-Pendant-Blind-Box", 
                      name: "THE MONSTERS Big into Energy Series Vinyl Plush Pendant Blind Box")
        }
        // æ¢å¤ç›‘æ§çŠ¶æ€
        restoreMonitoringStates()
    }
    
    // MARK: - å•†å“ç®¡ç†
    func addProduct(url: String, name: String, variant: ProductVariant = .singleBox, imageURL: String? = nil, monitoringInterval: TimeInterval = 300, autoStart: Bool = false) {
        let product = Product(url: url, name: name, variant: variant, imageURL: imageURL, monitoringInterval: monitoringInterval, autoStart: autoStart)
        products.append(product)
        saveProducts()
        addLog(for: product, status: .success, message: "å•†å“å·²æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨")
        
        if autoStart {
            startMonitoring(for: product.id)
        }
    }
    
    // æ–°å¢ï¼šæ·»åŠ å¤šå˜ä½“äº§å“
    func addMultiVariantProduct(baseURL: String, name: String, variants: [VariantDetail], imageURL: String? = nil, monitoringInterval: TimeInterval = 300, autoStart: Bool = false) {
        let product = Product(baseURL: baseURL, name: name, variants: variants, imageURL: imageURL, monitoringInterval: monitoringInterval, autoStart: autoStart)
        products.append(product)
        saveProducts()
        addLog(for: product, status: .success, message: "å¤šå˜ä½“å•†å“å·²æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨ (\(variants.count)ä¸ªå˜ä½“)")
        
        if autoStart {
            startMonitoring(for: product.id)
        }
    }
    
    // æ–°å¢ï¼šæ·»åŠ å•ä¸ªå˜ä½“åˆ°ç°æœ‰äº§å“
    func addVariantToProduct(productId: UUID, variant: VariantDetail) {
        guard let index = products.firstIndex(where: { $0.id == productId }) else { return }
        
        products[index].addVariant(variant)
        saveProducts()
        addLog(for: products[index], status: .success, message: "å·²æ·»åŠ æ–°å˜ä½“: \(variant.name)")
    }
    
    // æ–°å¢ï¼šç§»é™¤äº§å“çš„ç‰¹å®šå˜ä½“
    func removeVariantFromProduct(productId: UUID, variantId: UUID) {
        guard let index = products.firstIndex(where: { $0.id == productId }) else { return }
        
        let variantName = products[index].getVariant(by: variantId)?.name ?? "æœªçŸ¥å˜ä½“"
        products[index].removeVariant(id: variantId)
        saveProducts()
        addLog(for: products[index], status: .success, message: "å·²ç§»é™¤å˜ä½“: \(variantName)")
    }
    
    // æ–°å¢ï¼šå¼€å§‹ç›‘æ§ç‰¹å®šå˜ä½“
    func startMonitoringVariant(productId: String, variantId: String) {
        guard let productUUID = UUID(uuidString: productId),
              let variantUUID = UUID(uuidString: variantId),
              let index = products.firstIndex(where: { $0.id == productUUID }) else { return }
        var product = products[index]
        guard var variant = product.getVariant(by: variantUUID) else { return }
        
        variant.isMonitoring = true
        product.updateVariant(variant)
        products[index] = product
        saveProducts()
        
        // ç«‹å³æ£€æŸ¥è¯¥å˜ä½“
        checkVariantAvailability(product: product, variant: variant)
        
        // ä¸ºè¯¥å˜ä½“è®¾ç½®ç‹¬ç«‹å®šæ—¶å™¨
        let timerKey = "\(productId)_\(variantId)"
        let timer = Timer.scheduledTimer(withTimeInterval: product.monitoringInterval, repeats: true) { _ in
            if let currentProduct = self.products.first(where: { $0.id == productUUID }),
               let currentVariant = currentProduct.getVariant(by: variantUUID) {
                self.checkVariantAvailability(product: currentProduct, variant: currentVariant)
            }
        }
        
        variantTimers[timerKey] = timer
        addLog(for: product, status: .success, message: "å¼€å§‹ç›‘æ§å˜ä½“: \(variant.name)")
    }
    
    // æ–°å¢ï¼šåœæ­¢ç›‘æ§ç‰¹å®šå˜ä½“
    func stopMonitoringVariant(productId: String, variantId: String) {
        guard let productUUID = UUID(uuidString: productId),
              let variantUUID = UUID(uuidString: variantId),
              let index = products.firstIndex(where: { $0.id == productUUID }) else { return }
        var product = products[index]
        guard var variant = product.getVariant(by: variantUUID) else { return }
        
        variant.isMonitoring = false
        product.updateVariant(variant)
        products[index] = product
        saveProducts()
        
        // åœæ­¢è¯¥å˜ä½“çš„å®šæ—¶å™¨
        let timerKey = "\(productId)_\(variantId)"
        variantTimers[timerKey]?.invalidate()
        variantTimers.removeValue(forKey: timerKey)
        
        addLog(for: product, status: .success, message: "åœæ­¢ç›‘æ§å˜ä½“: \(variant.name)")
    }
    
    func removeProduct(at index: Int) {
        guard index < products.count else { return }
        let product = products[index]
        
        // åœæ­¢è¯¥å•†å“çš„ç›‘æ§
        if product.isMonitoring {
            stopMonitoring(for: product.id)
        }
        
        products.remove(at: index)
        saveProducts()
        addLog(for: product, status: .success, message: "å•†å“å·²ä»ç›‘æ§åˆ—è¡¨ç§»é™¤")
    }
    
    func updateProduct(_ product: Product) {
        if let index = products.firstIndex(where: { $0.id == product.id }) {
            products[index] = product
            saveProducts()
        }
    }
    
    func updateProductSettings(_ productId: UUID, interval: TimeInterval, autoStart: Bool, customUserAgent: String?) {
        if let index = products.firstIndex(where: { $0.id == productId }) {
            let wasMonitoring = products[index].isMonitoring
            
            products[index].monitoringInterval = interval
            products[index].autoStart = autoStart
            products[index].customUserAgent = customUserAgent
            
            // å¦‚æœæ­£åœ¨ç›‘æ§ä¸”é—´éš”æ”¹å˜ï¼Œé‡å¯ç›‘æ§
            if wasMonitoring {
                stopMonitoring(for: productId)
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    self.startMonitoring(for: productId)
                }
            }
            
            saveProducts()
            addLog(for: products[index], status: .success, message: "ç›‘æ§è®¾ç½®å·²æ›´æ–° - é—´éš”: \(Int(interval))ç§’")
        }
    }
    
    // MARK: - ç‹¬ç«‹ç›‘æ§æ§åˆ¶
    func startMonitoring(for productId: UUID) {
        guard let index = products.firstIndex(where: { $0.id == productId }) else { return }
        let product = products[index]
        
        guard !product.isMonitoring else { return }
        
        // å¯¹äºå¤šå˜ä½“äº§å“ï¼Œéœ€è¦å¯åŠ¨æ‰€æœ‰å˜ä½“çš„ç›‘æ§
        if product.variants.count > 1 {
            for variant in product.variants {
                if !variant.isMonitoring {
                    startMonitoringVariant(productId: productId.uuidString, variantId: variant.id.uuidString)
                }
            }
        } else {
            // å¯¹äºå•å˜ä½“äº§å“ï¼Œå¯åŠ¨ç¬¬ä¸€ä¸ªå˜ä½“çš„ç›‘æ§
            if let firstVariant = product.variants.first, !firstVariant.isMonitoring {
                startMonitoringVariant(productId: productId.uuidString, variantId: firstVariant.id.uuidString)
            }
        }
        
        // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
        checkProductAvailability(product)
        
        // è®¾ç½®è¯¥äº§å“çš„ç‹¬ç«‹å®šæ—¶å™¨
        let timer = Timer.scheduledTimer(withTimeInterval: product.monitoringInterval, repeats: true) { _ in
            self.checkProductAvailability(self.products.first(where: { $0.id == productId }) ?? product)
        }
        
        productTimers[product.id] = timer
        addLog(for: product, status: .success, message: "å¼€å§‹ç›‘æ§ï¼Œé—´éš” \(Int(product.monitoringInterval)) ç§’")
    }
    
    func stopMonitoring(for productId: UUID) {
        guard let index = products.firstIndex(where: { $0.id == productId }) else { return }
        
        let product = products[index]
        
        // åœæ­¢æ‰€æœ‰å˜ä½“çš„ç›‘æ§
        for variant in product.variants {
            if variant.isMonitoring {
                stopMonitoringVariant(productId: productId.uuidString, variantId: variant.id.uuidString)
            }
        }
        
        products[index] = product
        saveProducts()
        
        // åœæ­¢è¯¥äº§å“çš„å®šæ—¶å™¨
        productTimers[productId]?.invalidate()
        productTimers.removeValue(forKey: productId)
        
        addLog(for: product, status: .success, message: "åœæ­¢ç›‘æ§")
    }
    
    func startAllMonitoring() {
        for product in products {
            if product.autoStart || !product.isMonitoring {
                startMonitoring(for: product.id)
            }
        }
    }
    
    func stopAllMonitoring() {
        for product in products {
            if product.isMonitoring {
                stopMonitoring(for: product.id)
            }
        }
    }
    
    func restoreMonitoringStates() {
        // æ¢å¤åº”ç”¨å…³é—­å‰çš„ç›‘æ§çŠ¶æ€
        for product in products {
            if product.isMonitoring {
                // é‡æ–°å¼€å§‹ç›‘æ§
                var updatedProduct = product
                // åœæ­¢æ‰€æœ‰å˜ä½“ç›‘æ§çŠ¶æ€ï¼Œç„¶åé‡æ–°å¯åŠ¨
                for i in 0..<updatedProduct.variants.count {
                    updatedProduct.variants[i].isMonitoring = false
                }
                if let index = products.firstIndex(where: { $0.id == product.id }) {
                    products[index] = updatedProduct
                }
                startMonitoring(for: product.id)
            }
        }
    }
    
    // MARK: - ç«‹å³æ£€æŸ¥åŠŸèƒ½
    func instantCheck(for productId: UUID) {
        guard let product = products.first(where: { $0.id == productId }) else { return }
        
        addLog(for: product, status: .instantCheck, message: "æ‰§è¡Œç«‹å³æ£€æŸ¥...")
        checkProductAvailability(product)
    }
    
    func instantCheckAll() {
        for product in products {
            addLog(for: product, status: .instantCheck, message: "æ‰§è¡Œç«‹å³æ£€æŸ¥...")
            // æ·»åŠ å°å»¶è¿Ÿé¿å…åŒæ—¶å‘é€å¤ªå¤šè¯·æ±‚
            DispatchQueue.main.asyncAfter(deadline: .now() + Double.random(in: 0...2)) {
                self.checkProductAvailability(product)
            }
        }
    }
    
    // MARK: - å•†å“æ£€æŸ¥
    private func checkProductAvailability(_ product: Product) {
        guard let url = URL(string: product.url) else {
            addLog(for: product, status: .error, message: "æ— æ•ˆçš„URL")
            return
        }
        
        let startTime = Date()
        let request = createAntiDetectionRequest(for: url, with: product)
        
        URLSession.shared.dataTaskPublisher(for: request)
            .map { data, response -> (String, Int) in
                let statusCode = (response as? HTTPURLResponse)?.statusCode ?? 0
                return (String(data: data, encoding: .utf8) ?? "", statusCode)
            }
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { completion in
                    let responseTime = Date().timeIntervalSince(startTime)
                    switch completion {
                    case .failure(let error):
                        self.handleNetworkError(for: product, error: error, responseTime: responseTime)
                    case .finished:
                        break
                    }
                },
                receiveValue: { htmlContent, statusCode in
                    let responseTime = Date().timeIntervalSince(startTime)
                    self.parseProductStatus(from: htmlContent, for: product, responseTime: responseTime, statusCode: statusCode)
                }
            )
            .store(in: &cancellables)
    }
    
    // æ–°å¢ï¼šæ£€æŸ¥ç‰¹å®šå˜ä½“çš„å¯ç”¨æ€§
    private func checkVariantAvailability(product: Product, variant: VariantDetail) {
        guard let url = URL(string: variant.url) else {
            addLog(for: product, status: .error, message: "å˜ä½“URLæ— æ•ˆ: \(variant.name)")
            return
        }
        
        let startTime = Date()
        let request = createAntiDetectionRequest(for: url, with: product)
        
        URLSession.shared.dataTaskPublisher(for: request)
            .map { data, response -> (String, Int) in
                let statusCode = (response as? HTTPURLResponse)?.statusCode ?? 0
                return (String(data: data, encoding: .utf8) ?? "", statusCode)
            }
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { completion in
                    let responseTime = Date().timeIntervalSince(startTime)
                    switch completion {
                    case .failure(let error):
                        self.handleVariantNetworkError(for: product, variant: variant, error: error, responseTime: responseTime)
                    case .finished:
                        break
                    }
                },
                receiveValue: { htmlContent, statusCode in
                    let responseTime = Date().timeIntervalSince(startTime)
                    self.parseVariantStatus(from: htmlContent, for: product, variant: variant, responseTime: responseTime, statusCode: statusCode)
                }
            )
            .store(in: &cancellables)
    }
    
    private func handleVariantNetworkError(for product: Product, variant: VariantDetail, error: Error, responseTime: TimeInterval) {
        updateVariantStats(product: product, variantId: variant.id, incrementError: true)
        
        let errorMessage: String
        let logStatus: LogStatus
        
        switch error {
        case let urlError as URLError:
            switch urlError.code {
            case .timedOut:
                errorMessage = "[\(variant.name)] è¯·æ±‚è¶…æ—¶ - å¯èƒ½è§¦å‘äº†åçˆ¬è™«æœºåˆ¶"
                logStatus = .antiBot
            case .notConnectedToInternet:
                errorMessage = "[\(variant.name)] ç½‘ç»œè¿æ¥å·²æ–­å¼€"
                logStatus = .networkError
            default:
                errorMessage = "[\(variant.name)] ç½‘ç»œé”™è¯¯: \(urlError.localizedDescription)"
                logStatus = .networkError
            }
        default:
            errorMessage = "[\(variant.name)] æœªçŸ¥é”™è¯¯: \(error.localizedDescription)"
            logStatus = .error
        }
        
        addLog(for: product, status: logStatus, message: errorMessage, responseTime: responseTime)
        
        // å¦‚æœè¯¥å˜ä½“é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œåœæ­¢ç›‘æ§
        if let updatedVariant = getUpdatedVariant(product: product, variantId: variant.id),
           updatedVariant.errorCount >= product.maxRetries && updatedVariant.isMonitoring {
            stopMonitoringVariant(productId: product.id.uuidString, variantId: variant.id.uuidString)
            addLog(for: product, status: .error, message: "[\(variant.name)] é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œå·²è‡ªåŠ¨æš‚åœç›‘æ§")
        }
    }
    
    private func parseVariantStatus(from html: String, for product: Product, variant: VariantDetail, responseTime: TimeInterval, statusCode: Int) {
        updateVariantStats(product: product, variantId: variant.id, incrementError: false)
        
        // æ£€æŸ¥æ˜¯å¦è¢«åçˆ¬è™«æ£€æµ‹
        if statusCode == 403 || statusCode == 429 || html.contains("Access Denied") || html.contains("Cloudflare") {
            addLog(for: product, status: .antiBot, message: "[\(variant.name)] æ£€æµ‹åˆ°åçˆ¬è™«æœºåˆ¶ (HTTP \(statusCode))", responseTime: responseTime, httpStatusCode: statusCode)
            return
        }
        
        // æ£€æµ‹å…³é”®è¯æ¥åˆ¤æ–­å˜ä½“çŠ¶æ€
        let unavailableKeywords = [
            "out of stock", "sold out", "ausverkauft", "nicht verfÃ¼gbar",
            "temporarily unavailable", "vorÃ¼bergehend nicht verfÃ¼gbar",
            "sorry, this item is currently out of stock", "leider ausverkauft"
        ]
        
        let availableKeywords = [
            "add to cart", "in den warenkorb", "buy now", "jetzt kaufen",
            "verfÃ¼gbar", "available", "add to bag", "in stock"
        ]
        
        let htmlLowercase = html.lowercased()
        
        // è·å–å½“å‰å˜ä½“çŠ¶æ€
        guard let productIndex = products.firstIndex(where: { $0.id == product.id }),
              var currentVariant = products[productIndex].getVariant(by: variant.id) else { return }
        
        let wasAvailable = currentVariant.isAvailable
        
        // æ£€æŸ¥åº“å­˜çŠ¶æ€
        let isOutOfStock = unavailableKeywords.contains { keyword in
            htmlLowercase.contains(keyword)
        }
        
        let hasStock = availableKeywords.contains { keyword in
            htmlLowercase.contains(keyword)
        }
        
        currentVariant.isAvailable = hasStock && !isOutOfStock
        
        // æ›´æ–°å˜ä½“ä¿¡æ¯
        products[productIndex].updateVariant(currentVariant)
        saveProducts()
        
        // è®°å½•æ—¥å¿—
        let statusMessage = currentVariant.isAvailable ? "æœ‰åº“å­˜" : "ç¼ºè´§"
        let priceInfo = currentVariant.price != nil ? " (ä»·æ ¼: \(currentVariant.price!))" : ""
        
        if wasAvailable != currentVariant.isAvailable {
            let changeMessage = currentVariant.isAvailable ? "ğŸ‰ å˜ä½“ä¸Šæ¶äº†ï¼" : "å˜ä½“å·²ä¸‹æ¶"
            addLog(for: products[productIndex], status: .availabilityChanged, 
                  message: "[\(variant.name)] \(changeMessage) - \(statusMessage)\(priceInfo)", 
                  responseTime: responseTime, httpStatusCode: statusCode)
            
            // å¦‚æœå˜ä½“ä»ç¼ºè´§å˜ä¸ºæœ‰è´§ï¼Œå‘é€é€šçŸ¥
            if !wasAvailable && currentVariant.isAvailable {
                NotificationCenter.default.post(
                    name: NSNotification.Name("VariantAvailable"),
                    object: ["product": products[productIndex], "variant": currentVariant]
                )
            }
        } else {
            addLog(for: products[productIndex], status: .success, 
                  message: "[\(variant.name)] çŠ¶æ€æ£€æŸ¥: \(statusMessage)\(priceInfo)", 
                  responseTime: responseTime, httpStatusCode: statusCode)
        }
    }
    
    // æ–°å¢ï¼šæ›´æ–°å˜ä½“ç»Ÿè®¡ä¿¡æ¯
    private func updateVariantStats(product: Product, variantId: UUID, incrementError: Bool) {
        guard let productIndex = products.firstIndex(where: { $0.id == product.id }),
              var variant = products[productIndex].getVariant(by: variantId) else { return }
        
        variant.incrementCheck()
        if incrementError {
            variant.incrementError()
        } else {
            variant.incrementSuccess()
        }
        
        products[productIndex].updateVariant(variant)
        saveProducts()
    }
    
    // æ–°å¢ï¼šè·å–æ›´æ–°åçš„å˜ä½“
    private func getUpdatedVariant(product: Product, variantId: UUID) -> VariantDetail? {
        guard let currentProduct = products.first(where: { $0.id == product.id }) else { return nil }
        return currentProduct.getVariant(by: variantId)
    }
    
    private func handleNetworkError(for product: Product, error: Error, responseTime: TimeInterval) {
        updateProductStats(product, incrementError: true)
        
        let errorMessage: String
        let logStatus: LogStatus
        
        switch error {
        case let urlError as URLError:
            switch urlError.code {
            case .timedOut:
                errorMessage = "è¯·æ±‚è¶…æ—¶ - å¯èƒ½è§¦å‘äº†åçˆ¬è™«æœºåˆ¶"
                logStatus = .antiBot
            case .notConnectedToInternet:
                errorMessage = "ç½‘ç»œè¿æ¥å·²æ–­å¼€"
                logStatus = .networkError
            default:
                errorMessage = "ç½‘ç»œé”™è¯¯: \(urlError.localizedDescription)"
                logStatus = .networkError
            }
        case let nsError as NSError:
            if nsError.domain == NSURLErrorDomain && (nsError.code == 403 || nsError.code == 429) {
                errorMessage = "è®¿é—®è¢«æ‹’ç» - è§¦å‘åçˆ¬è™«æ£€æµ‹"
                logStatus = .antiBot
            } else {
                errorMessage = "é”™è¯¯: \(nsError.localizedDescription)"
                logStatus = .error
            }
        default:
            errorMessage = "æœªçŸ¥é”™è¯¯: \(error.localizedDescription)"
            logStatus = .error
        }
        
        addLog(for: product, status: logStatus, message: errorMessage, responseTime: responseTime)
        
        if product.errorCount >= product.maxRetries && product.isMonitoring {
            stopMonitoring(for: product.id)
            addLog(for: product, status: .error, message: "é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œå·²è‡ªåŠ¨æš‚åœç›‘æ§")
        }
    }
    
    private func parseProductStatus(from html: String, for product: Product, responseTime: TimeInterval, statusCode: Int) {
        updateProductStats(product, incrementError: false)
        
        // æ£€æŸ¥æ˜¯å¦è¢«åçˆ¬è™«æ£€æµ‹
        if statusCode == 403 || statusCode == 429 || html.contains("Access Denied") || html.contains("Cloudflare") {
            addLog(for: product, status: .antiBot, message: "æ£€æµ‹åˆ°åçˆ¬è™«æœºåˆ¶ (HTTP \(statusCode))", responseTime: responseTime, httpStatusCode: statusCode)
            return
        }
        
        // ä½¿ç”¨å¢å¼ºçš„è§£æé€»è¾‘
        let parseResult = parseProductStatus(from: html, url: product.url)
        
        guard let productIndex = products.firstIndex(where: { $0.id == product.id }) else { return }
        var currentProduct = products[productIndex]
        
        // è®°å½•è§£æç»“æœçš„è¯¦ç»†ä¿¡æ¯
        var debugInfo: [String] = []
        debugInfo.append("è§£æç»“æœ:")
        debugInfo.append("- å•†å“åç§°: \(parseResult.name ?? "æœªæ£€æµ‹åˆ°")")
        debugInfo.append("- ä»·æ ¼: \(parseResult.price ?? "æœªæ£€æµ‹åˆ°")")
        debugInfo.append("- å›¾ç‰‡URL: \(parseResult.imageURL != nil ? "å·²æ£€æµ‹åˆ°" : "æœªæ£€æµ‹åˆ°")")
        debugInfo.append("- å˜ä½“æ•°é‡: \(parseResult.variants.count)")
        debugInfo.append("- åº“å­˜çŠ¶æ€: \(parseResult.isAvailable ? "æœ‰è´§" : "ç¼ºè´§")")
        
        // æ›´æ–°å•†å“ä¿¡æ¯
        if parseResult.name != "æœªçŸ¥å•†å“" && parseResult.name != currentProduct.name {
            currentProduct.name = parseResult.name!
        }
        
        // å¯¹äºå•å˜ä½“äº§å“ï¼Œæ›´æ–°ç¬¬ä¸€ä¸ªå˜ä½“çš„çŠ¶æ€
        if let firstVariantIndex = currentProduct.variants.indices.first {
            let wasAvailable = currentProduct.variants[firstVariantIndex].isAvailable
            var variant = currentProduct.variants[firstVariantIndex]
            
            // æ›´æ–°å˜ä½“ä¿¡æ¯
            variant.isAvailable = parseResult.isAvailable
            if let price = parseResult.price {
                variant.price = price
            }
            if let imageURL = parseResult.imageURL {
                variant.imageURL = imageURL
            }
            
            currentProduct.variants[firstVariantIndex] = variant
            
            // ä¿å­˜æ›´æ–°
            products[productIndex] = currentProduct
            saveProducts()
            
            // å‡†å¤‡æ—¥å¿—æ¶ˆæ¯
            let statusMessage = variant.isAvailable ? "æœ‰åº“å­˜" : "ç¼ºè´§"
            let priceInfo = variant.price != nil ? " (ä»·æ ¼: \(variant.price!))" : ""
            let nameInfo = parseResult.name != "æœªçŸ¥å•†å“" ? " - \(parseResult.name!)" : ""
            
            if wasAvailable != variant.isAvailable {
                let changeMessage = variant.isAvailable ? "ğŸ‰ å•†å“ä¸Šæ¶äº†ï¼" : "ğŸ“¦ å•†å“å·²ä¸‹æ¶"
                addLog(for: currentProduct, status: .availabilityChanged, 
                      message: "\(changeMessage)\(nameInfo) - \(statusMessage)\(priceInfo)", 
                      responseTime: responseTime, httpStatusCode: statusCode)
                
                // å¦‚æœå•†å“ä»ç¼ºè´§å˜ä¸ºæœ‰è´§ï¼Œå‘é€é€šçŸ¥
                if !wasAvailable && variant.isAvailable {
                    NotificationCenter.default.post(
                        name: NSNotification.Name("ProductAvailable"),
                        object: currentProduct
                    )
                }
            } else {
                addLog(for: currentProduct, status: .success, 
                      message: "âœ… çŠ¶æ€æ£€æŸ¥\(nameInfo): \(statusMessage)\(priceInfo)", 
                      responseTime: responseTime, httpStatusCode: statusCode)
            }
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯åˆ°æ—¥å¿—
            if currentProduct.enableDebugLogging {
                addLog(for: currentProduct, status: .info, 
                      message: debugInfo.joined(separator: "\n"), 
                      responseTime: responseTime)
            }
        }
    }
    
    // MARK: - å¤šæ¨¡å¼å•†å“åç§°æå–
    private func extractProductName(from html: String) -> String? {
        let patterns = [
            // JSON-LDç»“æ„åŒ–æ•°æ®ï¼ˆä¼˜å…ˆï¼‰
            "\"name\"\\s*:\\s*\"([^\"]+)\"",
            // Metaæ ‡ç­¾
            "<meta[^>]*property=[\"']og:title[\"'][^>]*content=[\"']([^\"']+)[\"']",
            "<meta[^>]*name=[\"']title[\"'][^>]*content=[\"']([^\"']+)[\"']",
            // HTMLæ ‡é¢˜æ ‡ç­¾
            "<title[^>]*>([^<]+)</title>",
            "<h1[^>]*>([^<]+)</h1>",
            "<h2[^>]*class=[\"'][^\"']*product[^\"']*[\"'][^>]*>([^<]+)</h2>",
            // ç‰¹å®šäºPopmartçš„é€‰æ‹©å™¨
            "<div[^>]*class=[\"'][^\"']*product-title[^\"']*[\"'][^>]*>([^<]+)</div>",
            "<span[^>]*class=[\"'][^\"']*product-name[^\"']*[\"'][^>]*>([^<]+)</span>",
            // é€šç”¨å•†å“åç§°ç±»
            "<[^>]*class=[\"'][^\"']*product[_-]?name[^\"']*[\"'][^>]*>([^<]+)<",
            "<[^>]*class=[\"'][^\"']*title[^\"']*[\"'][^>]*>([^<]+)<"
        ]
        
        for pattern in patterns {
            if let name = extractFirst(pattern: pattern, from: html) {
                let cleaned = name.trimmingCharacters(in: .whitespacesAndNewlines)
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                if !cleaned.isEmpty && cleaned.count > 2 {
                    return cleaned
                }
            }
        }
        return nil
    }
    
    // MARK: - å¤šå¸ç§ä»·æ ¼æå–
    private func extractPrice(from html: String) -> String? {
        let patterns = [
            // JSON-LDä»·æ ¼
            "\"price\"\\s*:\\s*\"?([0-9,\\.]+)\"?",
            "\"offers\"[^}]*\"price\"\\s*:\\s*\"?([0-9,\\.]+)\"?",
            // å„ç§å¸ç§æ ¼å¼
            "([â‚¬Â¥$Â£â‚©])\\s*([0-9,\\.]+)",
            "([0-9,\\.]+)\\s*([â‚¬Â¥$Â£â‚©])",
            // ä»·æ ¼ç±»å
            "<[^>]*class=[\"'][^\"']*price[^\"']*[\"'][^>]*>([^<]*[0-9,\\.]+[^<]*)<",
            "<[^>]*class=[\"'][^\"']*cost[^\"']*[\"'][^>]*>([^<]*[0-9,\\.]+[^<]*)<",
            "<[^>]*class=[\"'][^\"']*amount[^\"']*[\"'][^>]*>([^<]*[0-9,\\.]+[^<]*)<",
            // dataå±æ€§
            "data-price=[\"']([^\"']+)[\"']",
            "data-cost=[\"']([^\"']+)[\"']"
        ]
        
        for pattern in patterns {
            if let priceMatch = extractFirst(pattern: pattern, from: html) {
                let cleaned = priceMatch.trimmingCharacters(in: .whitespacesAndNewlines)
                if !cleaned.isEmpty {
                    return cleaned
                }
            }
        }
        return nil
    }
    
    // MARK: - å¤šæºå›¾ç‰‡æå–
    private func extractMainImage(from html: String, baseURL: String) -> String? {
        let patterns = [
            // Open Graphå›¾ç‰‡ï¼ˆä¼˜å…ˆï¼‰
            "<meta[^>]*property=[\"']og:image[\"'][^>]*content=[\"']([^\"']+)[\"']",
            // JSON-LDå›¾ç‰‡
            "\"image\"\\s*:\\s*\"([^\"]+)\"",
            // ä¸»å•†å“å›¾ç‰‡
            "<img[^>]*class=[\"'][^\"']*product[^\"']*main[^\"']*[\"'][^>]*src=[\"']([^\"']+)[\"']",
            "<img[^>]*class=[\"'][^\"']*main[^\"']*product[^\"']*[\"'][^>]*src=[\"']([^\"']+)[\"']",
            // é€šç”¨äº§å“å›¾ç‰‡
            "<img[^>]*class=[\"'][^\"']*product[_-]?image[^\"']*[\"'][^>]*src=[\"']([^\"']+)[\"']",
            "<img[^>]*alt=[\"'][^\"']*product[^\"']*[\"'][^>]*src=[\"']([^\"']+)[\"']"
        ]
        
        for pattern in patterns {
            if let imageURL = extractFirst(pattern: pattern, from: html) {
                let cleaned = imageURL.trimmingCharacters(in: .whitespacesAndNewlines)
                if !cleaned.isEmpty {
                    // å¤„ç†ç›¸å¯¹URL
                    if cleaned.hasPrefix("//") {
                        return "https:" + cleaned
                    } else if cleaned.hasPrefix("/") {
                        if let baseURLObj = URL(string: baseURL) {
                            return baseURLObj.scheme! + "://" + baseURLObj.host! + cleaned
                        }
                    } else if !cleaned.hasPrefix("http") {
                        if let baseURLObj = URL(string: baseURL) {
                            return baseURLObj.scheme! + "://" + baseURLObj.host! + "/" + cleaned
                        }
                    }
                    return cleaned
                }
            }
        }
        return nil
    }
    
    // MARK: - å˜ä½“ä¿¡æ¯æå–
    private func extractVariants(from html: String, productURL: String) -> [VariantDetail] {
        var variants: [VariantDetail] = []
        
        // 1. å°è¯•æå–JSONä¸­çš„å˜ä½“ä¿¡æ¯
        if let jsonVariants = extractJSONVariants(from: html, productURL: productURL) {
            variants.append(contentsOf: jsonVariants)
        }
        
        // 2. å¦‚æœæ²¡æœ‰JSONå˜ä½“ï¼Œå°è¯•HTMLå˜ä½“æå–
        if variants.isEmpty {
            if let htmlVariants = extractHTMLVariants(from: html, productURL: productURL) {
                variants.append(contentsOf: htmlVariants)
            }
        }
        
        // 3. å¦‚æœä»ç„¶æ²¡æœ‰å˜ä½“ï¼Œåˆ›å»ºé»˜è®¤å˜ä½“
        if variants.isEmpty {
            let defaultVariant = VariantDetail(
                id: UUID(),
                variant: .color("é»˜è®¤"),
                name: "é»˜è®¤å˜ä½“",
                price: extractPrice(from: html),
                isAvailable: determineAvailability(from: html),
                url: productURL,
                imageURL: extractMainImage(from: html, baseURL: productURL),
                sku: nil,
                stockLevel: nil,
                isMonitoring: false,
                lastChecked: Date(),
                totalChecks: 0,
                successfulChecks: 0,
                errorCount: 0
            )
            variants.append(defaultVariant)
        }
        
        return variants
    }
    
    // MARK: - JSONå˜ä½“æå–
    private func extractJSONVariants(from html: String, productURL: String) -> [VariantDetail]? {
        let jsonPatterns = [
            "\"variants\"\\s*:\\s*(\\[.*?\\])",
            "\"options\"\\s*:\\s*(\\[.*?\\])",
            "window\\.productData\\s*=\\s*(\\{.*?\\});",
            "<script[^>]*type=[\"']application/ld\\+json[\"'][^>]*>(.*?)</script>"
        ]
        
        for pattern in jsonPatterns {
            if let jsonString = extractFirst(pattern: pattern, from: html) {
                if let variants = parseJSONVariants(jsonString, productURL: productURL) {
                    return variants
                }
            }
        }
        return nil
    }
    
    // MARK: - HTMLå˜ä½“æå–
    private func extractHTMLVariants(from html: String, productURL: String) -> [VariantDetail]? {
        var variants: [VariantDetail] = []
        
        // æå–é¢œè‰²/å°ºç é€‰é¡¹
        let optionPatterns = [
            "<option[^>]*value=[\"']([^\"']+)[\"'][^>]*>([^<]+)</option>",
            "<button[^>]*data-variant=[\"']([^\"']+)[\"'][^>]*>([^<]+)</button>",
            "<div[^>]*class=[\"'][^\"']*variant[^\"']*[\"'][^>]*data-value=[\"']([^\"']+)[\"'][^>]*>([^<]+)</div>"
        ]
        
        for pattern in optionPatterns {
            let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive, .dotMatchesLineSeparators])
            let nsString = html as NSString
            let results = regex?.matches(in: html, options: [], range: NSRange(location: 0, length: nsString.length))
            
            results?.forEach { match in
                if match.numberOfRanges >= 3 {
                    let value = nsString.substring(with: match.range(at: 1))
                    let name = nsString.substring(with: match.range(at: 2)).trimmingCharacters(in: .whitespacesAndNewlines)
                    
                    if !name.isEmpty {
                        let variant = VariantDetail(
                            id: UUID(),
                            variant: .color(name),
                            name: name,
                            price: extractPrice(from: html),
                            isAvailable: determineAvailability(from: html),
                            url: productURL,
                            imageURL: extractMainImage(from: html, baseURL: productURL),
                            sku: value,
                            stockLevel: nil,
                            isMonitoring: false,
                            lastChecked: Date(),
                            totalChecks: 0,
                            successfulChecks: 0,
                            errorCount: 0
                        )
                        variants.append(variant)
                    }
                }
            }
        }
        
        return variants.isEmpty ? nil : variants
    }
    
    // MARK: - å¤šä¿¡å·åº“å­˜çŠ¶æ€åˆ¤æ–­
    private func determineAvailability(from html: String) -> Bool {
        let unavailablePatterns = [
            // å¤šè¯­è¨€ç¼ºè´§å…³é”®è¯
            "out.of.stock", "sold.out", "not.available", "unavailable",
            "ausverkauft", "nicht.verfÃ¼gbar", "Ã©puisÃ©", "non.disponible",
            "agotado", "no.disponible", "esaurito", "non.disponibile",
            "ç¼ºè´§", "å”®å®Œ", "æ— åº“å­˜", "å·²å”®å®Œ", "å“åˆ‡ã‚Œ", "ì¬ê³ ì—†ìŒ",
            // æŒ‰é’®çŠ¶æ€
            "disabled", "button.*disabled", "btn.*disabled",
            // CSSç±»å
            "out-of-stock", "sold-out", "not-available", "unavailable",
            // å…·ä½“æ–‡æœ¬
            "Add to Cart.*disabled", "åŠ å…¥è´­ç‰©è½¦.*disabled", "ç«‹å³è´­ä¹°.*disabled"
        ]
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«ç¼ºè´§ä¿¡å·
        for pattern in unavailablePatterns {
            let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive])
            if regex?.firstMatch(in: html, options: [], range: NSRange(location: 0, length: html.count)) != nil {
                return false
            }
        }
        
        // æ£€æŸ¥æœ‰è´§ä¿¡å·
        let availablePatterns = [
            "in.stock", "available", "add.to.cart", "buy.now",
            "verfÃ¼gbar", "hinzufÃ¼gen", "kaufen", "disponible", "ajouter",
            "disponible", "comprar", "disponibile", "acquista",
            "æœ‰åº“å­˜", "ç°è´§", "ç«‹å³è´­ä¹°", "åŠ å…¥è´­ç‰©è½¦", "åœ¨åº«ã‚ã‚Š", "ì¬ê³ ìˆìŒ"
        ]
        
        for pattern in availablePatterns {
            let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive])
            if regex?.firstMatch(in: html, options: [], range: NSRange(location: 0, length: html.count)) != nil {
                return true
            }
        }
        
        // é»˜è®¤å‡è®¾æœ‰è´§ï¼ˆä¿å®ˆç­–ç•¥ï¼‰
        return true
    }
    
    // MARK: - è¾…åŠ©æ–¹æ³•
    private func extractFirst(pattern: String, from html: String) -> String? {
        let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive, .dotMatchesLineSeparators])
        let nsString = html as NSString
        if let match = regex?.firstMatch(in: html, options: [], range: NSRange(location: 0, length: nsString.length)) {
            if match.numberOfRanges >= 2 {
                return nsString.substring(with: match.range(at: 1))
            }
        }
        return nil
    }
    
    private func parseJSONVariants(_ jsonString: String, productURL: String) -> [VariantDetail]? {
        // ç®€åŒ–çš„JSONè§£æï¼Œå®é™…é¡¹ç›®ä¸­åº”ä½¿ç”¨æ›´å¥å£®çš„JSONè§£æ
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨JSONSerializationæˆ–Codableè¿›è¡Œè§£æ
        return nil
    }
}

// é€šç”¨ä»·æ ¼æå–æ–¹æ³•
private func extractPrice(from html: String) -> String? {
    let pricePatterns = [
        #"â‚¬\s*(\d+[.,]\d{2})"#,
        #"EUR\s*(\d+[.,]\d{2})"#,
        #"(\d+[.,]\d{2})\s*â‚¬"#,
        #"(\d+[.,]\d{2})\s*EUR"#,
        #"price[^>]*>.*?â‚¬\s*(\d+[.,]\d{2})"#,
        #"class="[^"]*price[^"]*"[^>]*>.*?(\d+[.,]\d{2})"#
    ]
    
    for pattern in pricePatterns {
        if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
            let range = NSRange(location: 0, length: html.count)
            if let match = regex.firstMatch(in: html, options: [], range: range) {
                if let priceRange = Range(match.range(at: 1), in: html) {
                    let priceString = String(html[priceRange])
                        .replacingOccurrences(of: ",", with: ".")
                    return "â‚¬\(priceString)"
                }
            }
        }
    }
    
    return nil
}

// æå–å•†å“åç§°
private func extractProductName(from html: String) -> String? {
    let namePatterns = [
        #"<h1[^>]*class="[^"]*product[^"]*title[^"]*"[^>]*>(.*?)</h1>"#,
        #"<h1[^>]*>(.*?)</h1>"#,
        #"<meta[^>]*property="og:title"[^>]*content="([^"]+)""#,
        #"<title>(.*?)</title>"#
    ]
    
    for pattern in namePatterns {
        if let range = html.range(of: pattern, options: [.regularExpression, .caseInsensitive]) {
            let match = String(html[range])
            let cleanedName = match.replacingOccurrences(of: #"<[^>]*>"#, with: "", options: [.regularExpression])
                .replacingOccurrences(of: #"content="|""#, with: "", options: [.regularExpression])
                .trimmingCharacters(in: .whitespacesAndNewlines)
            
            if !cleanedName.isEmpty {
                return cleanedName
            }
        }
    }
    
    return nil
}

// å°†SKUæ˜ å°„åˆ°å˜ä½“ç±»å‹
private func mapSkuToVariant(sku: String, title: String) -> ProductVariant {
    let lowercaseSku = sku.lowercased()
    let lowercaseTitle = title.lowercased()
    
    if lowercaseSku.contains("set") || lowercaseTitle.contains("æ•´å¥—") || lowercaseTitle.contains("set") {
        return .wholeSet
    } else if lowercaseSku.contains("random") || lowercaseTitle.contains("éšæœº") || lowercaseTitle.contains("random") {
        return .random
    } else if lowercaseSku.contains("limited") || lowercaseTitle.contains("é™å®š") || lowercaseTitle.contains("limited") {
        return .limited
    } else if lowercaseSku.contains("specific") || lowercaseTitle.contains("æŒ‡å®š") || lowercaseTitle.contains("specific") {
        return .specific
    } else {
        return .singleBox
    }
}

// MARK: - å¢å¼ºç‰ˆè§£ææ–¹æ³• - ä»…ä¿ç•™æ ¸å¿ƒè§£æé€»è¾‘ï¼Œç”¨ä½œè¾…åŠ©åŠŸèƒ½

